<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroid Avoidance Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Space Theme Styling */
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'Space Mono', monospace;
            background-color: #0d1117; /* GitHub Dark Background */
            color: #c9d1d9;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
        }

        #game-container {
            border: 2px solid #238636; /* GitHub Green Border */
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(35, 134, 54, 0.4);
            max-width: 90vw;
        }

        canvas {
            display: block;
            background-color: #010409; /* Deep space black */
            /* Add touch action none to prevent default swipe behavior */
            touch-action: none;
        }

        .controls {
            background-color: #161b22; /* Slightly lighter dark background */
            padding: 1.5rem;
            border-top: 1px solid #238636;
            border-radius: 0 0 10px 10px;
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: space-around;
            align-items: center;
        }

        .game-button {
            padding: 0.75rem 1.5rem;
            background-color: #238636;
            color: white;
            font-weight: bold;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            text-transform: uppercase;
        }

        .game-button:hover {
            background-color: #2ea043;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }

        .game-button:active {
            transform: translateY(1px);
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
        }

        .score-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #58a6ff; /* GitHub Blue */
        }

        /* Responsive Canvas Scaling */
        @media (min-width: 768px) {
            #game-container {
                width: 700px;
                height: 700px;
            }
        }
    </style>
</head>
<body>

    <header class="text-center mb-6">
        <h1 class="text-4xl font-bold text-green-400">Asteroid Avoidance</h1>
        <p class="text-gray-400 mt-2">A JavaScript Canvas Physics Simulation</p>
    </header>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <div id="score" class="score-display">Score: 0</div>
            <button id="startButton" class="game-button" onclick="game.start()">Start Game</button>
        </div>
    </div>
    
    <div class="mt-6 text-center text-sm text-gray-500 max-w-md p-4 bg-gray-900 rounded-lg shadow-inner">
        <p class="font-bold text-gray-300 mb-2">Controls:</p>
        <div class="flex justify-center space-x-4">
            <span class="p-2 bg-gray-700 rounded-md">W / Up Arrow: Thrust</span>
            <span class="p-2 bg-gray-700 rounded-md">A / Left Arrow: Rotate Left</span>
            <span class="p-2 bg-gray-700 rounded-md">D / Right Arrow: Rotate Right</span>
        </div>
        <p class="mt-2 text-yellow-400">Mouse Click / Tap: Shoot</p>
    </div>

    <script>
        // Set canvas size for initial load (will be resized by JS)
        const CANVAS_WIDTH = 700;
        const CANVAS_HEIGHT = 700;

        // --- Vector Class for Physics ---
        class Vector {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            add(v) {
                return new Vector(this.x + v.x, this.y + v.y);
            }

            subtract(v) {
                return new Vector(this.x - v.x, this.y - v.y);
            }

            scale(scalar) {
                return new Vector(this.x * scalar, this.y * scalar);
            }

            magnitude() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            normalize() {
                const mag = this.magnitude();
                return mag > 0 ? this.scale(1 / mag) : new Vector(0, 0);
            }
        }

        // --- Game Entity Base Class ---
        class Entity {
            constructor(x, y, radius) {
                this.position = new Vector(x, y);
                this.velocity = new Vector(0, 0);
                this.radius = radius;
                this.isAlive = true; // For collision cleanup
            }

            update(dt, canvasWidth, canvasHeight) {
                // Basic movement update
                this.position = this.position.add(this.velocity.scale(dt));
                
                // Wrap around edges
                if (this.position.x < 0) this.position.x = canvasWidth;
                if (this.position.x > canvasWidth) this.position.x = 0;
                if (this.position.y < 0) this.position.y = canvasHeight;
                if (this.position.y > canvasHeight) this.position.y = 0;
            }

            draw(ctx) {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Projectile Class (NEW) ---
        class Projectile extends Entity {
            constructor(x, y, angle) {
                super(x, y, 3);
                this.speed = 400; // pixels/second
                
                // Set velocity based on ship's angle
                const velocityX = Math.cos(angle) * this.speed;
                const velocityY = Math.sin(angle) * this.speed;
                this.velocity = new Vector(velocityX, velocityY);
                this.lifetime = 2; // seconds before removal
                this.timeElapsed = 0;
            }

            update(dt, canvasWidth, canvasHeight) {
                // Update position
                this.position = this.position.add(this.velocity.scale(dt));
                
                // Check if projectile is out of bounds (no wrap)
                if (this.position.x < 0 || this.position.x > canvasWidth || 
                    this.position.y < 0 || this.position.y > canvasHeight) {
                    this.isAlive = false;
                }

                // Check lifetime
                this.timeElapsed += dt;
                if (this.timeElapsed > this.lifetime) {
                    this.isAlive = false;
                }
            }

            draw(ctx) {
                ctx.fillStyle = '#ff0000'; // Red bullet
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }


        // --- Player Ship Class ---
        class Ship extends Entity {
            constructor(x, y) {
                super(x, y, 10);
                this.angle = 0; // Radians
                this.thrustPower = 300; // Units/second^2
                this.rotationSpeed = 3; // Radians/second
                this.frictionFactor = 0.99; // Damping
                this.isThrusting = false;
                this.fireRate = 0.2; // seconds between shots
                this.cooldown = 0;
            }

            update(dt, canvasWidth, canvasHeight) {
                // Update cooldown timer
                if (this.cooldown > 0) {
                    this.cooldown -= dt;
                }

                // Apply friction (velocity damping)
                this.velocity = this.velocity.scale(this.frictionFactor);

                if (this.isThrusting) {
                    // Calculate thrust vector based on angle
                    const thrustX = Math.cos(this.angle) * this.thrustPower * dt;
                    const thrustY = Math.sin(this.angle) * this.thrustPower * dt;
                    this.velocity = this.velocity.add(new Vector(thrustX * dt, thrustY * dt));
                }

                super.update(dt, canvasWidth, canvasHeight);
            }
            
            shoot(projectiles) {
                if (this.cooldown <= 0) {
                    // Create a new projectile slightly ahead of the nose
                    const noseX = this.position.x + Math.cos(this.angle) * (this.radius + 5);
                    const noseY = this.position.y + Math.sin(this.angle) * (this.radius + 5);
                    
                    const newProjectile = new Projectile(noseX, noseY, this.angle);
                    projectiles.push(newProjectile);
                    this.cooldown = this.fireRate;
                }
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(this.angle);

                // Draw the ship (a simple triangle)
                ctx.strokeStyle = '#58a6ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(15, 0);       // Nose
                ctx.lineTo(-10, -10);    // Left fin
                ctx.lineTo(-5, 0);       // Center cutout
                ctx.lineTo(-10, 10);     // Right fin
                ctx.closePath();
                ctx.stroke();

                // Draw thrust flame if thrusting
                if (this.isThrusting) {
                    ctx.fillStyle = '#ff7b72'; // Red/Orange
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(-18, -4);
                    ctx.lineTo(-18, 4);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // --- Asteroid Class ---
        class Asteroid extends Entity {
            constructor(x, y, radius, speed) {
                super(x, y, radius);
                this.velocity = new Vector(
                    (Math.random() - 0.5) * speed,
                    (Math.random() - 0.5) * speed
                );
                this.color = '#7d8995'; // Gray-ish
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.5; // rad/s
            }

            update(dt, canvasWidth, canvasHeight) {
                super.update(dt, canvasWidth, canvasHeight);
                this.rotation += this.rotationSpeed * dt; // Rotate the drawing
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(this.rotation);
                
                // Draw a simple asteroid shape (circle with rotation for effect)
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.stroke();

                ctx.restore();
            }
        }

        // --- Main Game Logic Class ---
        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.scoreElement = document.getElementById('score');
                this.startButton = document.getElementById('startButton');

                // Game constants
                this.MAX_ASTEROIDS = 15; // Increased for better shooting challenge
                this.INITIAL_ASTEROID_SPEED = 50; // pixels/second
                this.FIXED_TIMESTEP = 1000 / 60; // 60 updates per second (ms)

                // State
                this.gameState = 'menu'; // 'menu', 'playing', 'gameover'
                this.score = 0;
                this.ship = null;
                this.asteroids = [];
                this.projectiles = []; // NEW: Array for bullets
                this.keys = {};
                this.lastTime = 0;
                this.accumulator = 0; // For fixed timestep

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));
                
                // NEW: Mouse/Touch interactivity
                this.canvas.addEventListener('click', (e) => this.handleMouseClick(e));
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
                
                this.renderMenu();
            }

            resizeCanvas() {
                // Ensure canvas scales within the container
                const container = document.getElementById('game-container');
                const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.9, CANVAS_WIDTH, CANVAS_HEIGHT);
                this.canvas.width = size;
                this.canvas.height = size;
                container.style.width = `${size}px`;
                container.style.height = `${size}px`;
                this.render(); // Redraw immediately after resize
            }

            // --- Game State Management ---

            start() {
                if (this.gameState === 'playing') return;

                this.gameState = 'playing';
                this.score = 0;
                this.ship = new Ship(this.canvas.width / 2, this.canvas.height / 2);
                this.asteroids = [];
                this.projectiles = []; // Reset projectiles
                
                this.spawnAsteroids();
                this.startButton.textContent = 'Restart Game';
                this.startButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                this.startButton.classList.add('bg-green-600', 'hover:bg-green-700');
                
                this.scoreInterval = setInterval(() => {
                    if (this.gameState === 'playing') {
                        this.score += 10;
                    }
                }, 100);

                requestAnimationFrame(this.loop.bind(this));
            }

            gameOver() {
                this.gameState = 'gameover';
                clearInterval(this.scoreInterval);
                this.startButton.textContent = 'Game Over! Play Again?';
                this.startButton.classList.remove('bg-green-600', 'hover:bg-green-700');
                this.startButton.classList.add('bg-red-600', 'hover:bg-red-700');
            }

            spawnAsteroids() {
                while (this.asteroids.length < this.MAX_ASTEROIDS) {
                    const radius = Math.random() * 20 + 15;
                    const speed = this.INITIAL_ASTEROID_SPEED + (this.score / 100); // Speed up with score
                    
                    // Spawn outside of a safe zone around the ship
                    let x, y;
                    do {
                        x = Math.random() * this.canvas.width;
                        y = Math.random() * this.canvas.height;
                    } while (Math.abs(x - this.ship.position.x) < 150 && Math.abs(y - this.ship.position.y) < 150);

                    this.asteroids.push(new Asteroid(x, y, radius, speed));
                }
            }

            // --- Input Handling (Keyboard) ---

            handleKeyDown(e) {
                this.keys[e.key.toLowerCase()] = true;
                this.keys[e.key] = true; // Handle Arrow Keys
                // Prevent scrolling/default behavior for control keys
                if (['w', 'a', 's', 'd', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                }
            }

            handleKeyUp(e) {
                this.keys[e.key.toLowerCase()] = false;
                this.keys[e.key] = false; // Handle Arrow Keys
            }

            // --- Input Handling (Mouse/Touch) (NEW) ---
            
            handleMouseClick(e) {
                if (this.gameState === 'playing') {
                    // Mouse click shoots
                    this.ship.shoot(this.projectiles);
                }
            }
            
            handleTouchStart(e) {
                if (this.gameState !== 'playing') return;
                e.preventDefault(); // Prevent scrolling/default gestures
                
                // Use the first touch point to check for thrust zone
                const rect = this.canvas.getBoundingClientRect();
                const touchX = e.touches[0].clientX - rect.left;
                
                // If touch is on the right half of the screen, enable thrust
                if (touchX > this.canvas.width / 2) {
                    this.ship.isThrusting = true;
                } else {
                    // Tap on the left half shoots (handled by touchend for a clean tap)
                }
            }

            handleTouchMove(e) {
                if (this.gameState !== 'playing' || e.touches.length === 0) return;
                e.preventDefault();
                
                // Simple Rotation/Steering based on touch position relative to ship
                const rect = this.canvas.getBoundingClientRect();
                const touchX = e.touches[0].clientX - rect.left;
                const touchY = e.touches[0].clientY - rect.top;
                
                // Calculate desired angle towards touch point
                const dx = touchX - this.ship.position.x;
                const dy = touchY - this.ship.position.y;
                const desiredAngle = Math.atan2(dy, dx);
                
                // Simple smooth rotation towards the target angle
                let angleDiff = desiredAngle - this.ship.angle;
                
                // Normalize angle difference to [-PI, PI]
                if (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                if (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                // Apply rotation based on speed limit
                const rotationAmount = Math.min(Math.abs(angleDiff), this.ship.rotationSpeed * (this.FIXED_TIMESTEP / 1000));
                this.ship.angle += Math.sign(angleDiff) * rotationAmount;
            }

            handleTouchEnd(e) {
                if (this.gameState !== 'playing') return;
                
                // Check if touch ended and thrust was active
                if (this.ship.isThrusting) {
                    this.ship.isThrusting = false;
                }

                // If no touches remain, and it was a tap (not a long drag), shoot
                if (e.touches.length === 0) {
                    // Simple tap detection is hard, but we can assume a quick lift-off is a shot.
                    this.ship.shoot(this.projectiles);
                }
            }


            handleInput(dt) {
                // Keyboard Input for Rotation (Steering)
                if (this.keys['a'] || this.keys['ArrowLeft']) {
                    this.ship.angle -= this.ship.rotationSpeed * dt;
                }
                if (this.keys['d'] || this.keys['ArrowRight']) {
                    this.ship.angle += this.ship.rotationSpeed * dt;
                }

                // Keyboard Input for Thrust (Override touch thrust if key is pressed)
                if (this.keys['w'] || this.keys['ArrowUp']) {
                    this.ship.isThrusting = true;
                } else if (!this.keys['w'] && !this.keys['ArrowUp']) {
                    // Only turn off thrust if the key is not pressed and touch didn't enable it
                    // NOTE: TouchMove/TouchEnd handles turning off touch thrust
                }
            }

            // --- Physics & Update ---

            update(dt) {
                // Player update
                this.handleInput(dt);
                this.ship.update(dt, this.canvas.width, this.canvas.height);

                // Projectile update
                this.projectiles.forEach(p => p.update(dt, this.canvas.width, this.canvas.height));

                // Asteroid updates
                this.asteroids.forEach(asteroid => {
                    asteroid.update(dt, this.canvas.width, this.canvas.height);
                });
                
                // --- Collision Checks ---
                if (this.checkShipCollision()) {
                    this.gameOver();
                }
                this.checkProjectileCollision();

                // Cleanup dead entities
                this.projectiles = this.projectiles.filter(p => p.isAlive);
                this.asteroids = this.asteroids.filter(a => a.isAlive);


                // Keep asteroid count up
                if (this.asteroids.length < this.MAX_ASTEROIDS) {
                    this.spawnAsteroids();
                }
            }

            checkShipCollision() {
                for (const asteroid of this.asteroids) {
                    const distanceVector = this.ship.position.subtract(asteroid.position);
                    const distance = distanceVector.magnitude();
                    const minDistance = this.ship.radius + asteroid.radius;

                    if (distance < minDistance) {
                        return true; // Ship collision detected
                    }
                }
                return false;
            }
            
            checkProjectileCollision() {
                // Check for collisions between projectiles and asteroids
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const p = this.projectiles[i];
                    for (let j = this.asteroids.length - 1; j >= 0; j--) {
                        const a = this.asteroids[j];

                        const distanceVector = p.position.subtract(a.position);
                        const distance = distanceVector.magnitude();
                        const minDistance = p.radius + a.radius;

                        if (distance < minDistance) {
                            // Collision detected
                            p.isAlive = false; // Destroy bullet
                            a.isAlive = false; // Destroy asteroid
                            this.score += 50; // Award points
                            break; // Bullet can only hit one asteroid
                        }
                    }
                }
            }


            // --- Rendering ---

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = this.canvas.style.backgroundColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.scoreElement.textContent = `Score: ${this.score}`;

                if (this.gameState === 'playing' || this.gameState === 'gameover') {
                    // Draw entities
                    this.projectiles.forEach(p => p.draw(this.ctx)); // Draw projectiles first
                    this.asteroids.forEach(asteroid => asteroid.draw(this.ctx));
                    this.ship.draw(this.ctx);
                    
                    if (this.gameState === 'gameover') {
                        this.renderGameOver();
                    }
                } else {
                    this.renderMenu();
                }
            }

            renderMenu() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#c9d1d9';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.font = 'bold 30px "Space Mono", monospace';
                this.ctx.fillText('ASTEROID AVOIDANCE', this.canvas.width / 2, this.canvas.height / 2 - 30);
                this.ctx.font = '20px "Space Mono", monospace';
                this.ctx.fillText('Press "Start Game" to begin!', this.canvas.width / 2, this.canvas.height / 2 + 20);
            }

            renderGameOver() {
                this.ctx.fillStyle = 'rgba(185, 28, 28, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.font = 'bold 40px "Space Mono", monospace';
                this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 40);
                this.ctx.font = '25px "Space Mono", monospace';
                this.ctx.fillText(`Final Score: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 10);
                this.ctx.font = '15px "Space Mono", monospace';
                this.ctx.fillText('Press Restart Game to try again.', this.canvas.width / 2, this.canvas.height / 2 + 50);
            }

            // --- Main Loop (Fixed Timestep) ---

            loop(currentTime) {
                if (this.gameState !== 'playing' && this.gameState !== 'gameover') return;

                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                this.accumulator += deltaTime;
                
                // Use a while loop to ensure updates are consistent, even if FPS dips
                while (this.accumulator >= this.FIXED_TIMESTEP) {
                    const dtSeconds = this.FIXED_TIMESTEP / 1000;
                    this.update(dtSeconds);
                    this.accumulator -= this.FIXED_TIMESTEP;
                }

                this.render();

                if (this.gameState === 'playing') {
                    requestAnimationFrame(this.loop.bind(this));
                }
            }
        }

        // Initialize the game on window load
        window.onload = function () {
            window.game = new Game('gameCanvas');
            // The game will start in 'menu' state and wait for the user to press the button.
        }
    </script>

</body>
</html>
