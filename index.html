<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asteroid Avoidance Game</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Space Theme Styling */
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');
        
        body {
            font-family: 'Space Mono', monospace;
            background-color: #0d1117; /* GitHub Dark Background */
            color: #c9d1d9;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
        }

        #game-container {
            border: 2px solid #238636; /* GitHub Green Border */
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 40px rgba(35, 134, 54, 0.4);
            max-width: 90vw;
        }

        canvas {
            display: block;
            background-color: #010409; /* Deep space black */
        }

        .controls {
            background-color: #161b22; /* Slightly lighter dark background */
            padding: 1.5rem;
            border-top: 1px solid #238636;
            border-radius: 0 0 10px 10px;
            width: 100%;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: space-around;
            align-items: center;
        }

        .game-button {
            padding: 0.75rem 1.5rem;
            background-color: #238636;
            color: white;
            font-weight: bold;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            text-transform: uppercase;
        }

        .game-button:hover {
            background-color: #2ea043;
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }

        .game-button:active {
            transform: translateY(1px);
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
        }

        .score-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #58a6ff; /* GitHub Blue */
        }

        /* Responsive Canvas Scaling */
        @media (min-width: 768px) {
            #game-container {
                width: 700px;
                height: 700px;
            }
        }
    </style>
</head>
<body>

    <header class="text-center mb-6">
        <h1 class="text-4xl font-bold text-green-400">Asteroid Avoidance</h1>
        <p class="text-gray-400 mt-2">A JavaScript Canvas Physics Simulation</p>
    </header>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="controls">
            <div id="score" class="score-display">Score: 0</div>
            <button id="startButton" class="game-button" onclick="game.start()">Start Game</button>
        </div>
    </div>
    
    <div class="mt-6 text-center text-sm text-gray-500 max-w-md p-4 bg-gray-900 rounded-lg shadow-inner">
        <p class="font-bold text-gray-300 mb-2">Controls:</p>
        <div class="flex justify-center space-x-4">
            <span class="p-2 bg-gray-700 rounded-md">W / Up Arrow: Thrust</span>
            <span class="p-2 bg-gray-700 rounded-md">A / Left Arrow: Rotate Left</span>
            <span class="p-2 bg-gray-700 rounded-md">D / Right Arrow: Rotate Right</span>
        </div>
    </div>

    <script>
        // Set canvas size for initial load (will be resized by JS)
        const CANVAS_WIDTH = 700;
        const CANVAS_HEIGHT = 700;

        // --- Vector Class for Physics ---
        class Vector {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }

            add(v) {
                return new Vector(this.x + v.x, this.y + v.y);
            }

            subtract(v) {
                return new Vector(this.x - v.x, this.y - v.y);
            }

            scale(scalar) {
                return new Vector(this.x * scalar, this.y * scalar);
            }

            magnitude() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            normalize() {
                const mag = this.magnitude();
                return mag > 0 ? this.scale(1 / mag) : new Vector(0, 0);
            }
        }

        // --- Game Entity Base Class ---
        class Entity {
            constructor(x, y, radius) {
                this.position = new Vector(x, y);
                this.velocity = new Vector(0, 0);
                this.radius = radius;
            }

            update(dt, canvasWidth, canvasHeight) {
                // Basic movement update
                this.position = this.position.add(this.velocity.scale(dt));
                
                // Wrap around edges
                if (this.position.x < 0) this.position.x = canvasWidth;
                if (this.position.x > canvasWidth) this.position.x = 0;
                if (this.position.y < 0) this.position.y = canvasHeight;
                if (this.position.y > canvasHeight) this.position.y = 0;
            }

            draw(ctx) {
                ctx.fillStyle = 'white';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // --- Player Ship Class ---
        class Ship extends Entity {
            constructor(x, y) {
                super(x, y, 10);
                this.angle = 0; // Radians
                this.thrustPower = 300; // Units/second^2
                this.rotationSpeed = 3; // Radians/second
                this.frictionFactor = 0.99; // Damping
                this.isThrusting = false;
            }

            update(dt, canvasWidth, canvasHeight) {
                // Apply friction (velocity damping)
                this.velocity = this.velocity.scale(this.frictionFactor);

                if (this.isThrusting) {
                    // Calculate thrust vector based on angle
                    const thrustX = Math.cos(this.angle) * this.thrustPower * dt;
                    const thrustY = Math.sin(this.angle) * this.thrustPower * dt;
                    this.velocity = this.velocity.add(new Vector(thrustX * dt, thrustY * dt));
                }

                super.update(dt, canvasWidth, canvasHeight);
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                ctx.rotate(this.angle);

                // Draw the ship (a simple triangle)
                ctx.strokeStyle = '#58a6ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(15, 0);       // Nose
                ctx.lineTo(-10, -10);    // Left fin
                ctx.lineTo(-5, 0);       // Center cutout
                ctx.lineTo(-10, 10);     // Right fin
                ctx.closePath();
                ctx.stroke();

                // Draw thrust flame if thrusting
                if (this.isThrusting) {
                    ctx.fillStyle = '#ff7b72'; // Red/Orange
                    ctx.beginPath();
                    ctx.moveTo(-10, 0);
                    ctx.lineTo(-18, -4);
                    ctx.lineTo(-18, 4);
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            }
        }

        // --- Asteroid Class ---
        class Asteroid extends Entity {
            constructor(x, y, radius, speed) {
                super(x, y, radius);
                this.velocity = new Vector(
                    (Math.random() - 0.5) * speed,
                    (Math.random() - 0.5) * speed
                );
                this.color = '#7d8995'; // Gray-ish
            }

            draw(ctx) {
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
            }
        }

        // --- Main Game Logic Class ---
        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.scoreElement = document.getElementById('score');
                this.startButton = document.getElementById('startButton');

                // Game constants
                this.MAX_ASTEROIDS = 10;
                this.INITIAL_ASTEROID_SPEED = 50; // pixels/second
                this.FIXED_TIMESTEP = 1000 / 60; // 60 updates per second (ms)

                // State
                this.gameState = 'menu'; // 'menu', 'playing', 'gameover'
                this.score = 0;
                this.ship = null;
                this.asteroids = [];
                this.keys = {};
                this.lastTime = 0;
                this.accumulator = 0; // For fixed timestep

                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                window.addEventListener('keydown', (e) => this.handleKeyDown(e));
                window.addEventListener('keyup', (e) => this.handleKeyUp(e));
                
                this.renderMenu();
            }

            resizeCanvas() {
                // Ensure canvas scales within the container
                const container = document.getElementById('game-container');
                const size = Math.min(window.innerWidth * 0.9, window.innerHeight * 0.9, CANVAS_WIDTH, CANVAS_HEIGHT);
                this.canvas.width = size;
                this.canvas.height = size;
                container.style.width = `${size}px`;
                container.style.height = `${size}px`;
                this.render(); // Redraw immediately after resize
            }

            // --- Game State Management ---

            start() {
                if (this.gameState === 'playing') return;

                this.gameState = 'playing';
                this.score = 0;
                this.ship = new Ship(this.canvas.width / 2, this.canvas.height / 2);
                this.asteroids = [];
                
                this.spawnAsteroids();
                this.startButton.textContent = 'Restart Game';
                this.startButton.classList.remove('bg-red-600', 'hover:bg-red-700');
                this.startButton.classList.add('bg-green-600', 'hover:bg-green-700');
                
                this.scoreInterval = setInterval(() => {
                    if (this.gameState === 'playing') {
                        this.score += 10;
                    }
                }, 100);

                requestAnimationFrame(this.loop.bind(this));
            }

            gameOver() {
                this.gameState = 'gameover';
                clearInterval(this.scoreInterval);
                this.startButton.textContent = 'Game Over! Play Again?';
                this.startButton.classList.remove('bg-green-600', 'hover:bg-green-700');
                this.startButton.classList.add('bg-red-600', 'hover:bg-red-700');
            }

            spawnAsteroids() {
                while (this.asteroids.length < this.MAX_ASTEROIDS) {
                    const radius = Math.random() * 20 + 15;
                    const speed = this.INITIAL_ASTEROID_SPEED + (this.score / 100); // Speed up with score
                    
                    // Spawn outside of a safe zone around the ship
                    let x, y;
                    do {
                        x = Math.random() * this.canvas.width;
                        y = Math.random() * this.canvas.height;
                    } while (Math.abs(x - this.ship.position.x) < 150 && Math.abs(y - this.ship.position.y) < 150);

                    this.asteroids.push(new Asteroid(x, y, radius, speed));
                }
            }

            // --- Input Handling ---

            handleKeyDown(e) {
                this.keys[e.key.toLowerCase()] = true;
                this.keys[e.key] = true; // Handle Arrow Keys
            }

            handleKeyUp(e) {
                this.keys[e.key.toLowerCase()] = false;
                this.keys[e.key] = false; // Handle Arrow Keys
            }

            handleInput(dt) {
                // Rotation
                if (this.keys['a'] || this.keys['ArrowLeft']) {
                    this.ship.angle -= this.ship.rotationSpeed * dt;
                }
                if (this.keys['d'] || this.keys['ArrowRight']) {
                    this.ship.angle += this.ship.rotationSpeed * dt;
                }

                // Thrust
                if (this.keys['w'] || this.keys['ArrowUp']) {
                    this.ship.isThrusting = true;
                } else {
                    this.ship.isThrusting = false;
                }
            }

            // --- Physics & Update ---

            update(dt) {
                // Player update
                this.handleInput(dt);
                this.ship.update(dt, this.canvas.width, this.canvas.height);

                // Asteroid updates
                this.asteroids.forEach(asteroid => {
                    asteroid.update(dt, this.canvas.width, this.canvas.height);
                });

                // Collision Check
                if (this.checkCollision()) {
                    this.gameOver();
                }

                // Keep asteroid count up
                if (this.asteroids.length < this.MAX_ASTEROIDS) {
                    this.spawnAsteroids();
                }
            }

            checkCollision() {
                for (const asteroid of this.asteroids) {
                    const distanceVector = this.ship.position.subtract(asteroid.position);
                    const distance = distanceVector.magnitude();
                    const minDistance = this.ship.radius + asteroid.radius;

                    if (distance < minDistance) {
                        return true; // Collision detected
                    }
                }
                return false;
            }

            // --- Rendering ---

            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = this.canvas.style.backgroundColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                this.scoreElement.textContent = `Score: ${this.score}`;

                if (this.gameState === 'playing' || this.gameState === 'gameover') {
                    // Draw entities
                    this.asteroids.forEach(asteroid => asteroid.draw(this.ctx));
                    this.ship.draw(this.ctx);
                    
                    if (this.gameState === 'gameover') {
                        this.renderGameOver();
                    }
                } else {
                    this.renderMenu();
                }
            }

            renderMenu() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#c9d1d9';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.font = 'bold 30px "Space Mono", monospace';
                this.ctx.fillText('ASTEROID AVOIDANCE', this.canvas.width / 2, this.canvas.height / 2 - 30);
                this.ctx.font = '20px "Space Mono", monospace';
                this.ctx.fillText('Press "Start Game" to begin!', this.canvas.width / 2, this.canvas.height / 2 + 20);
            }

            renderGameOver() {
                this.ctx.fillStyle = 'rgba(185, 28, 28, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.font = 'bold 40px "Space Mono", monospace';
                this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 40);
                this.ctx.font = '25px "Space Mono", monospace';
                this.ctx.fillText(`Final Score: ${this.score}`, this.canvas.width / 2, this.canvas.height / 2 + 10);
                this.ctx.font = '15px "Space Mono", monospace';
                this.ctx.fillText('Press Restart Game to try again.', this.canvas.width / 2, this.canvas.height / 2 + 50);
            }

            // --- Main Loop (Fixed Timestep) ---

            loop(currentTime) {
                if (this.gameState !== 'playing' && this.gameState !== 'gameover') return;

                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                this.accumulator += deltaTime;
                
                // Use a while loop to ensure updates are consistent, even if FPS dips
                while (this.accumulator >= this.FIXED_TIMESTEP) {
                    const dtSeconds = this.FIXED_TIMESTEP / 1000;
                    this.update(dtSeconds);
                    this.accumulator -= this.FIXED_TIMESTEP;
                }

                this.render();

                if (this.gameState === 'playing') {
                    requestAnimationFrame(this.loop.bind(this));
                }
            }
        }

        // Initialize the game on window load
        window.onload = function () {
            window.game = new Game('gameCanvas');
            // The game will start in 'menu' state and wait for the user to press the button.
        }
    </script>

</body>
</html>
